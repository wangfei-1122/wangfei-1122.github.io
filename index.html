<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Java集合框架" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/23/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/" class="article-date">
  <time datetime="2019-11-23T06:51:03.000Z" itemprop="datePublished">2019-11-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/23/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">Java集合框架</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Java集合框架</p>
<p>Java集合框架主要包括两种类型的容器，一种是集合（Collection），另一种是图（Map）。Collection接口又有3种子类型，List、Set和Queue，再下面是一些抽象类，最后是具体实现类，常用的有ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap等等。Map常用的有HashMap,LinkedHashMap等。</p>
<p>二、Collection接口<br>1.List</p>
<p>List接口扩展自Collection，它可以定义一个允许重复的有序集合，从List接口中的方法来看，List接口主要是增加了面向位置的操作，允许在指定位置上操作元素，同时增加了一个能够双向遍历线性表的新列表迭代器ListIterator。AbstractList类提供了List接口的部分实现，AbstractSequentialList扩展自AbstractList，主要是提供对链表的支持。下面介绍List接口的两个重要的具体实现类，也是我们可能最常用的类，ArrayList和LinkedList。</p>
<p>1.1ArrayList</p>
<p>通过阅读ArrayList的源码，我们可以很清楚地看到里面的逻辑，它是用数组存储元素的，这个数组可以动态创建，如果元素个数超过了数组的容量，那么就创建一个更大的新数组，并将当前数组中的所有元素都复制到新数组中。假设第一次是集合没有任何元素，下面以插入一个元素为例看看源码的实现。</p>
<p>1、找到add()实现方法。</p>
<p>   public boolean add(E e) {<br>        ensureCapacityInternal(size + 1);  // Increments modCount!!<br>        elementData[size++] = e;<br>        return true;<br>    }</p>
<p>2、此方法主要是确定将要创建的数组大小。</p>
<p>  private void ensureCapacityInternal(int minCapacity) {<br>        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {<br>            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);<br>        }</p>
<pre><code>    ensureExplicitCapacity(minCapacity);
}

private void ensureExplicitCapacity(int minCapacity) {
    modCount++;
    if (minCapacity - elementData.length &gt; 0)
        grow(minCapacity);
}</code></pre><p>3、最后是创建数组，可以明显的看到先是确定了添加元素后的大小之后将元素复制到新数组中。</p>
<pre><code>private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
    if (newCapacity - minCapacity &lt; 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
        newCapacity = hugeCapacity(minCapacity);
    // minCapacity is usually close to size, so this is a win:
    elementData = Arrays.copyOf(elementData, newCapacity);
}</code></pre><p>1.2LinkedList</p>
<p>同样，我们打开LinkedList的源文件，不难看到LinkedList是在一个链表中存储元素。</p>
<p>在学习数据结构的时候，我们知道链表和数组的最大区别在于它们对元素的存储方式的不同导致它们在对数据进行不同操作时的效率不同，同样，ArrayList与LinkedList也是如此，实际使用中我们需要根据特定的需求选用合适的类，如果除了在末尾外不能在其他位置插入或者删除元素，那么ArrayList效率更高，如果需要经常插入或者删除元素，就选择LinkedList。</p>
<p>1.3CopyOnWriteArrayList</p>
<p>CopyOnWriteArrayList，是一个线程安全的List接口的实现，它使用了ReentrantLock锁来保证在并发情况下提供高性能的并发读取。</p>
<p>2.Set</p>
<p>Set接口扩展自Collection，它与List的不同之处在于，规定Set的实例不包含重复的元素。在一个规则集内，一定不存在两个相等的元素。AbstractSet是一个实现Set接口的抽象类，Set接口有三个具体实现类，分别是散列集HashSet、链式散列集LinkedHashSet和树形集TreeSet。</p>
<p>2.1HashSet</p>
<p>散列集HashSet是一个用于实现Set接口的具体类，可以使用它的无参构造方法来创建空的散列集，也可以由一个现有的集合创建散列集。在散列集中，有两个名词需要关注，初始容量和客座率。客座率是确定在增加规则集之前，该规则集的饱满程度，当元素个数超过了容量与客座率的乘积时，容量就会自动翻倍。</p>
<p>从输出结果我们可以看到，规则集里最后有4个元素，而且在输出时元素还是无序的。</p>
<p>2.2LinkedHashSet</p>
<p>LinkedHashSet是用一个链表实现来扩展HashSet类，它支持对规则集内的元素排序。HashSet中的元素是没有被排序的，而LinkedHashSet中的元素可以按照它们插入规则集的顺序提取。</p>
<p>2.3TreeSet</p>
<p>TreeSet扩展自AbstractSet，并实现了NavigableSet，AbstractSet扩展自AbstractCollection，树形集是一个有序的Set，其底层是一颗树，这样就能从Set里面提取一个有序序列了。在实例化TreeSet时，我们可以给TreeSet指定一个比较器Comparator来指定树形集中的元素顺序。树形集中提供了很多便捷的方法。</p>
<p>3.Queue</p>
<p>队列是一种先进先出的数据结构，元素在队列末尾添加，在队列头部删除。Queue接口扩展自Collection，并提供插入、提取、检验等操作。</p>
<p>上图中，方法offer表示向队列添加一个元素，poll()与remove()方法都是移除队列头部的元素，两者的区别在于如果队列为空，那么poll()返回的是null，而remove()会抛出一个异常。方法element()与peek()主要是获取头部元素，不删除。</p>
<p>接口Deque，是一个扩展自Queue的双端队列，它支持在两端插入和删除元素，因为LinkedList类实现了Deque接口，所以通常我们可以使用LinkedList来创建一个队列。PriorityQueue类实现了一个优先队列，优先队列中元素被赋予优先级，拥有高优先级的先被删除。</p>
<p>三、Map接口<br>1.HashMap</p>
<p>HashMap是基于哈希表的Map接口的非同步实现，继承自AbstractMap，AbstractMap是部分实现Map接口的抽象类。在平时的开发中，HashMap的使用还是比较多的。我们知道ArrayList主要是用数组来存储元素的，LinkedList是用链表来存储的，那么HashMap的实现原理是什么呢？先看下面这张图：</p>
<p>在之前的版本中，HashMap采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当链表中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，HashMap采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/23/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/" data-id="ck3b80zdi0001p0r99vgh6245" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-EL表达式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/20/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="article-date">
  <time datetime="2019-11-20T08:47:15.000Z" itemprop="datePublished">2019-11-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/20/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/">EL表达式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>EL 全名为Expression Language</p>
<p>EL 语法很简单，它最大的特点就是使用上很方便。接下来介绍EL主要的语法结构：</p>
<p>${sessionScope.user.sex}</p>
<p>所有EL都是以${为起始、以}为结尾的。上述EL范例的意思是：从Session的范围中，取得</p>
<p>用户的性别。假若依照之前JSP Scriptlet的写法如下：</p>
<p>User user =(User)session.getAttribute(“user”);</p>
<p>String sex =user.getSex( );</p>
<p>两者相比较之下，可以发现EL 的语法比传统JSP Scriptlet 更为方便、简洁。</p>
<p>.与 [ ] 运算符</p>
<p>EL 提供 . 和 [ ] 两种运算符来导航数据。下列两者所代表的意思是一样的：</p>
<p>${sessionScope.user.sex}等于${sessionScope.user[“sex”]}</p>
<p>. 和 [ ] 也可以同时混合使用，如下：</p>
<p>${sessionScope.shoppingCart[0].price}</p>
<p>回传结果为shoppingCart中第一项物品的价格。</p>
<p>不过，以下两种情况，两者会有差异：</p>
<p>(1) 当要存取的属性名称中包含一些特殊字符，如. 或 – 等并非字母或数字的符号，就一定要使用 [ ]，</p>
<p>例如：${user.My-Name }</p>
<p>上述是不正确的方式，应当改为：${user[“My-Name”] }</p>
<p>(2) 我们来考虑下列情况：</p>
<p>${sessionScope.user[data]}</p>
<p>此时，data 是一个变量，假若data的值为”sex”时，那上述的例子等于${sessionScope.user.sex}；</p>
<p>假若data 的值为”name”时，它就等于${sessionScope.user.name}。</p>
<p>因此，如果要动态取值时，就可以用上述的方法来做，但. 无法做到动态取值。</p>
<p> EL 变量</p>
<p>EL 存取变量数据的方法很简单，例如：${username}。它的意思是取出某一范围中名称为username的变量。</p>
<p>因为我们并没有指定哪一个范围的username，所以它的默认值会先从Page 范围找，假如找不到，</p>
<p>再依序到Request、Session、Application范围。假如途中找到username，就直接回传，不再继续找下去，</p>
<p>但是假如全部的范围都没有找到时，就回传null，当然EL表达式还会做出优化，页面上显示空白，而不是打印输出NULL。</p>
<p>属性范围（jstl名称）</p>
<p>EL中的名称</p>
<p>Page</p>
<p>PageScope</p>
<p>Request</p>
<p>RequestScope</p>
<p>Session</p>
<p>SessionScope</p>
<p>Application</p>
<p>ApplicationScope</p>
<p>我们也可以指定要取出哪一个范围的变量：</p>
<p>范例</p>
<p>说明</p>
<p>${pageScope.username}</p>
<p>取出Page范围的username变量</p>
<p>${requestScope.username}</p>
<p>取出Request范围的username变量</p>
<p>${sessionScope.username}</p>
<p>取出Session范围的username变量</p>
<p>${applicationScope.username}</p>
<p>取出Application范围的username变量</p>
<p>其中，pageScope、requestScope、sessionScope和applicationScope都是EL 的隐含对象，</p>
<p>由它们的名称可以很容易猜出它们所代表的意思，</p>
<p>例如：${sessionScope.username}是取出Session范围的username 变量。这种写法是不是比之前JSP 的写法：</p>
<p>String username =(String) session.getAttribute(“username”);容易、简洁许多.</p>
<p>自动转变类型</p>
<p>EL 除了提供方便存取变量的语法之外，它另外一个方便的功能就是：自动转变类型，我们来看下面这个范例：</p>
<p>${param.count + 20}</p>
<p>假若窗体传来count的值为10时，那么上面的结果为30。之前没接触过JSP 的读者可能会认为上面的例子是理所当然的，</p>
<p>但是在JSP 1.2 之中不能这样做，原因是从窗体所传来的值，它们的类型一律是String，所以当你接收之后，必须再将它转为其他类型，</p>
<p>如：int、float 等等，然后才能执行一些数学运算，下面是之前的做法：</p>
<p>String str_count =request.getParameter(“count”);</p>
<p>int count =Integer.parseInt(str_count);</p>
<p>count = count + 20;<br>所以，注意不要和java的语法（当字符串和数字用“+”链接时会把数字转换为字符串）搞混淆喽。</p>
<p>EL 隐含对象</p>
<p>JSP有9个隐含对象，而EL也有自己的隐含对象。EL隐含对象总共有11 个</p>
<p>隐含对象</p>
<p>类型</p>
<p>说明</p>
<p>PageContext</p>
<p>javax.servlet.ServletContext</p>
<p>表示此JSP的PageContext</p>
<p>PageScope</p>
<p>java.util.Map</p>
<p>取得Page范围的属性名称所对应的值</p>
<p>RequestScope</p>
<p>java.util.Map</p>
<p>取得Request范围的属性名称所对应的值</p>
<p>sessionScope</p>
<p>java.util.Map</p>
<p>取得Session范围的属性名称所对应的值</p>
<p>applicationScope</p>
<p>java.util.Map</p>
<p>取得Application范围的属性名称所对应的值</p>
<p>param</p>
<p>java.util.Map</p>
<p>如同ServletRequest.getParameter(String name)。回传String类型的值</p>
<p>paramValues</p>
<p>java.util.Map</p>
<p>如同ServletRequest.getParameterValues(String name)。回传String[]类型的值</p>
<p>header</p>
<p>java.util.Map</p>
<p>如同ServletRequest.getHeader(String name)。回传String类型的值</p>
<p>headerValues</p>
<p>java.util.Map</p>
<p>如同ServletRequest.getHeaders(String name)。回传String[]类型的值</p>
<p>cookie</p>
<p>java.util.Map</p>
<p>如同HttpServletRequest.getCookies()</p>
<p>initParam</p>
<p>java.util.Map</p>
<p>如同ServletContext.getInitParameter(String name)。回传String类型的值</p>
<p>不过有一点要注意的是如果你要用EL输出一个常量的话，字符串要加双引号，不然的话EL会默认把你认为的常量当做一个变量来处理，</p>
<p>这时如果这个变量在4个声明范围不存在的话会输出空，如果存在则输出该变量的值。</p>
<p>属性(Attribute)与范围(Scope)</p>
<p>与范围有关的EL 隐含对象包含以下四个：pageScope、requestScope、sessionScope 和</p>
<p>applicationScope，它们基本上就和JSP的pageContext、request、session和application一样，所以笔者在这里只稍略说明。</p>
<p>不过必须注意的是，这四个隐含对象只能用来取得范围属性值，即JSP中的getAttribute(String name)，却不能取得其他相关信息，</p>
<p>例如：JSP中的request对象除可以存取属性之外，还可以取得用户的请求参数或表头信息等等。</p>
<p>但是在EL中，它就只能单纯用来取得对应范围的属性值，</p>
<p>例如：我们要在session 中储存一个属性，它的名称为username，在JSP 中使用session.getAttribute(“username”)来取得username 的值，</p>
<p> 但是在EL中，则是使用${sessionScope.username}来取得其值的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/20/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/" data-id="ck3b80zcw0000p0r9hca9fjym" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java知识点" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/15/Java%E7%9F%A5%E8%AF%86%E7%82%B9/" class="article-date">
  <time datetime="2019-11-15T01:20:41.000Z" itemprop="datePublished">2019-11-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/15/Java%E7%9F%A5%E8%AF%86%E7%82%B9/">Java知识点</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>javaSE（标准版） javaEE（企业版） javaME（微型版）<br>JDK（java开发工具包）JRE（java运行环境）IDE（集成开发环境）<br>Java SE（Java Platform，Standard Edition）。Java SE 以前称为 J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程序。Java SE 包含了支持 Java Web 服务开发的类，并为 Java Platform，Enterprise Edition（Java EE）提供基础。 J2SE就是做那种桌面安装程序样的，像QQ，WORD那种应用程序。<br>Java EE（Java Platform，Enterprise Edition）。这个版本以前称为 J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端 Java 应用程序。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web 2.0 应用程序。 J2EE 就是做基于Internet的应用程序，像选课系统，企业网站，银行系统之类的。<br>Java ME（Java Platform，Micro Edition）。这个版本以前称为 J2ME。Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME 包括灵活的用户界面、健壮的安全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序的丰富支持。基于 Java ME 规范的应用程序只需编写一次，就可以用于许多设备，而且可以利用每个设备的本机功能。 J2ME就是做嵌入式系统开发的，像手机游戏之类的，像现在流行的Android操作系统。<br>JDK（Java Development Kit）。<br>JRE（Java Runtime Environment）<br>IDE（Ind Depvelopment Environment）<br>一、面向对象<br>类、对象、变量<br>（1）所有的Java程序都已类class为组织单元；类由属性和方法两部分组成<br>（2）先创建对象，再使用对象<br>（3）成员变量：类中定义，自动定义初始值<br>局部变量：类方法中定义（两变量同名，局部变量有更高的优先级）<br>构造方法<br>构造方法是定义在java类中的一个用来初始化对象的方法，与类同名且没有返回值。<br>public 构造方法名（）{<br>}<br>其中构造方法名与类同名；当没有指定的构造方法时，系统会自动添加无参构造方法<br>Static使用<br>Static修饰的成员属于整个类，被类的所有对象共享。可通过使用类名直接访问静态成员，也可通过对象名<br>Static可以修饰变量、方法和代码块<br>（1）Static使用之静态方法<br>public class Helloworld {<br>public static void print() {<br>System.out.println(“***”);<br>}<br>public static void main(String[] args) {<br>    Helloworld.print();<br>    Helloworld demo = new Helloworld;<br>    demo.print();<br>}<br>}<br>注意：静态方法中可以直接调用同类的静态成员，但不可以直接调用非静态成员；普通成员方法中可以直接访问同类的非静态变量和静态变量；静态方法中不能直接调用非静态成员方法<br>（2）Static使用之静态初始化块<br>静态初始化块在类加载时执行，且只会执行一次，同时静态初始化块只能给静态变量赋值，不能初始化普通成员<br>public class Helloworld {<br>int num1;<br>int num2;<br>static int num3;<br>public Helloworld() {<br>    num1 = 91;<br>    System.out.println(“构造方法为num1赋值”);<br>    num2 = 74;<br>    System.out.println(“初始化块为num2赋值”);<br>    num3 = 83;<br>    System.out.println(“静态初始化块为num3赋值”);<br>}</p>
<p>public static void main(String[] args) {<br>    Helloworld hello = new Helloworld();<br>    System.out.println(hello.num1);<br>    System.out.println(hello.num2);<br>    System.out.println(num3);<br>    Helloworld hello2 = new Helloworld();<br>}<br>}<br>运行结果：静态初始化块为num3赋值<br>初始化块为num2赋值<br>构造方法为num1赋值<br>91<br>74<br>83<br>初始化块为num2赋值<br>构造方法为num1赋值<br>二、java面向对象的特性<br>封装性：将类的某些信息隐藏在内部，通过类的方法来实现操作访问<br>步骤：<br>1 修改属性可见性；<br>2 创建getter\setter方法；<br>3在方法中加入属性控制语句<br>(1)静态内部类:<br>public class SOuter {<br>private int a = 99;<br>static int b = 1;<br>public static class SInner {<br>    int b = 2;</p>
<pre><code>public void test() {
    System.out.println(&quot;访问外部类b&quot; + SOuter.b);
    System.out.println(&quot;访问内部类b&quot; + b);
}</code></pre><p>}</p>
<p>public static void main(String[] args) {</p>
<pre><code>//三行表示
SInner sInner;
sInner = new SInner();
sInner.test();

//两行表示
SInner si = new SInner();
si.test();

//一行表示
new SInner().test();</code></pre><p>}<br>}<br>(2)成员内部类：访问外部类时使用this指针<br>（3）方法内部类：只能在该方法中使用，且不能使用访问控制符和Static修饰符<br>2. 继承性<br>（1）一般形式：class 子类 extends 父类<br>（2）方法重写：子类对继承的父类方法不满意可以重写，调用时优先调用子类方法<br>（3）继承的初始化顺序：先初始化父类，再到子类；先执行初始化对象中属性，再执行狗在方法中的初始化<br>（4）父类对象–属性初始化–构造方法–子类对象–属性初始化–构造方法<br>（5）注意：如果子类构造方法中没有显示调用父类的构造方法，默认调用父类无参构造方法，若此父类没用无参的构造方法，则编译出错<br>多态性<br>引用多态：父类的引用可以指向本类的对象，也可指向子类的对象<br>方法多态：创建本类对象时，调用的方法为本类方法；创建子类对象时，调用的方法为子类的重写的方法或者继承的方法<br>（1）抽象类<br>用关键字abstract修饰：抽象类只用声明不需要实现；包含抽象方法的类为抽象类；抽象类不能直接创建，可以定义引用变量。<br>public abstract class Telphone{<br>public abstract void call(); //抽象方法没有方法体，以分号结束<br>}<br>（2）接口（一种特殊的类，有全局变量和公共抽象方法组成）<br>[修饰符] class 类名 extends 父类implemrnts 接口1,2……<br>{类体部分<br>}<br>注：接口经常与匿名内部类配合使用<br>public interface Iplay{<br>public void phone();<br>}<br>public class People implements Iplay{<br>public static void main(String[] args){<br>People test=new People();<br>test.phone();<br>}<br>public void phone(){<br>System.out.println(“手机可以玩游戏”);<br>}<br>}<br>1.String、StringBuilder、StringBuffer的区别是什么，String为什么是不可变的？<br>不可变性<br>String类的底层源码中，通过final关键字修饰字符串数组，private final char value[]，所以是不可变的。StringBuffer和StringBuilder类是集成自 AbstractStringBuilder 类， AbstractStringBuilder 类中的变量没有用final关键字修饰，所以是可变的。<br>线程安全性<br>String是不可变的，是常量，所以是线程安全的。StringBuilder和StringBuffer都继承自AbstractStringBuilder 类，StringBuffer对方法加了同步锁，所以是线程安全的，而StringBuilder没有加同步锁，所以是线程不安全的。<br>性能<br>对String类型进行改变是都会new一个新的string对象，并指向新的对象；<br>StringBuffer直接通过改变自身变量的值，StringBuilder相对能提升性能，但有线程不安全的情况。<br>2.== 与 equals<br>==用来判断两个对象是否相等，基础数据类型比较的是值是否相等。<br>没有重写对象的equals方法时，也是用来比较两个对象是否相等，重写equals方法可以比较内容相等，返回true<br>3.try/catch/finally中finally是否一定执行<br>在以下4种特殊情况下，finally块不会被执行:<br>在finally语句块中发生了异常。<br>在前面的代码中用了System.exit()退出程序。<br>程序所在的线程死亡。<br>关闭CPU。<br>4.接口和抽象类的区别？<br>1.抽象类中可以实现方法，抽象接口不能实现方法（jdk1.8以后可以实现方法）；<br>2.接口中的变量默认是final类型，而抽象类不是；<br>3.类只能继承一个抽象类，而接口可以实现多个；<br>4.类继承接口需要实现所有方法，抽象类不需要；<br>5.接口不能用new实例化，可以声明。必须引用一个实现该接口的对象抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。<br>5.Arraylist 与 LinkedList 异同<br>安全性<br>ArrayList与LinkedList都是线程不安全的。<br>数据结构实现<br>ArryayList是基于Object数组，而LinkedList是基于双向循环链表（JDK1.6之前为循环链表，之后取消了循环）<br>插入删除的影响<br>ArrayList采用数组存储，插入删除受元素位置的影响；<br>LinkedList采用链表存储，插入删除不收元素位置影响；<br>访问元素<br>LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。<br>实现了RandomAccess接口的list，优先选择普通for循环 ，其次foreach,未实现RandomAccess接口的list， 优先选择iterator遍历(foreach遍历底层也是通过iterator实现的)，大size的数据，千万不要使用普通for循环<br>6.ArrayList 与 Vector 区别<br>Vector中所有方法都是同步的，在多线程操作中，同步操作会耗费时间，而ArrayList是不需要同步的，在不需要考虑线程安全时可以使用。<br>7.HashMap的底层实现<br>待补充完善<br>8.HashSet 和 HashMap 区别<br>HashMap实现Map接口，用来存储键值对，调用put方法添加元素，使用Key计算Hashcode，而HashSet实现Set接口，用来存储对象，调用add方法添加对象，使用对象计算hashcode，根据equals方法判断对象相等，执行效率的话，HashMap优与HashSet。<br>9.ConcurrentHashMap 和 Hashtable 的区别<br>ConcurrentHashMap 和 HashTable 的区别主要体现在实现线程安全的方式上不同。ConcurrentHashMap使用的是分段锁，HashTable使用的是同一把锁，因而在多线程并发中效率很低。<br>10.多线程实现方式<br>1.继承Thread类，2.实现Runnable接口，3.基于线程池实现</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/15/Java%E7%9F%A5%E8%AF%86%E7%82%B9/" data-id="ck3b80zej0006p0r91yumae62" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java接口总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/14/Java%E6%8E%A5%E5%8F%A3%E6%80%BB%E7%BB%93/" class="article-date">
  <time datetime="2019-11-14T10:59:25.000Z" itemprop="datePublished">2019-11-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/14/Java%E6%8E%A5%E5%8F%A3%E6%80%BB%E7%BB%93/">Java接口总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Java接口总结<br>Java不支持多继承性，即一个子类只能有一个父类；单继承使得java简单，易于管理，但如果要克服单继承性的缺点就要使用接口技术，是一个类可以实现多个接口，用关键字interface关键字来定义一个接口。<br>（1）接口声明：interface 接口名；    接口体:包括常量定义和方法定义，方法只允许声明不允许实现。<br>（2）接口使用：class A implements print,add       或者  class A extends A1 implements print,add<br>（3）当某个类使用接口的时候，必须给出所有方法的实现，方法的类型、参数一定要和接口的一致；接口的方法默认为public abstract，故类在实现时一定不能漏写public关键字；接口常量默认关键字为public static。<br>（4）因为接口中只含有public static final 常量和public abstract方法，故在写接口的时候可以省略这些关键字。<br>（5）如果接口的返回类型不是void，那么实现方法体的时候，至少要有一个return语句；如果接口的返回类型是void，可以除了大括号之外可以没有任何语句。<br>（6）Java提供的接口都在相应的包中，可以通过引入包使用相应的接口；也可以自定义接口，一个源文件就是由类和接口来组成的。<br>（7）类实现的接口的方法以及接口中的常量可以通过类的对象进行调用，常量也可以通过类名和接口名进行调用。<br>（8）接口声明的时候，如果加上关键字public，那么接口可以被任一个类进行调用，如果没有public则为友好型接口，只能被同一个包内的类进行调用。<br>（9）如果父类使用某个接口，那么子类也就使用了接口，不用再使用implements。<br>（10）接口可以通过extends继承接口。<br>（11）如果一个类声明实现一个接口但没有实现接口的所有方法，那么这个类一定得是abstract类。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/14/Java%E6%8E%A5%E5%8F%A3%E6%80%BB%E7%BB%93/" data-id="ck3b80zdl0002p0r9g762ba5o" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-jsp九大内置对象" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/14/jsp%E4%B9%9D%E5%A4%A7%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/" class="article-date">
  <time datetime="2019-11-14T10:45:30.000Z" itemprop="datePublished">2019-11-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/14/jsp%E4%B9%9D%E5%A4%A7%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/">jsp九大内置对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>   JSP内置对象，是指可以不加声明和创建就可以在JSP页面脚本(Java程序片和Java表达式)中使用的成员变量。<br>   JSP共有以下9种基本内置组件(可与ASP的6种内部组件相对应):</p>
<p>1.request对象<br>   客户端的请求信息被封装在request对象中，通过它才能了解到客户的需求，然后做出响应。它是   HttpServletRequest类的实例。<br>   request对象具有请求域,即完成客户端的请求之前,该对象一直有效。</p>
<p>序号 方 法 说 明</p>
<p>   1 object getAttribute(String name) 返回指定属性的属性值</p>
<p>   2 Enumeration getAttributeNames() 返回所有可用属性名的枚举</p>
<p>   3 String getCharacterEncoding() 返回字符编码方式</p>
<p>   4 int getContentLength() 返回请求体的长度(以字节数)</p>
<p>   5 String getContentType() 得到请求体的MIME类型</p>
<p>   6 ServletInputStream getInputStream() 得到请求体中一行的二进制流</p>
<p>   7 String getParameter(String name) 返回name指定参数的参数值</p>
<p>   8 Enumeration getParameterNames() 返回可用参数名的枚举</p>
<p>   9 String[] getParameterValues(String name) 返回包含参数name的所有值的数组</p>
<p>   10 String getProtocol() 返回请求用的协议类型及版本号</p>
<p>   11 String getScheme() 返回请求用的计划名,如:http.https及ftp等</p>
<p>   12 String getServerName() 返回接受请求的服务器主机名</p>
<p>   13 int getServerPort() 返回服务器接受此请求所用的端口号</p>
<p>   14 BufferedReader getReader() 返回解码过了的请求体</p>
<p>   15 String getRemoteAddr() 返回发送此请求的客户端IP地址</p>
<p>   16 String getRemoteHost() 返回发送此请求的客户端主机名</p>
<p>   17 void setAttribute(String key,Object obj) 设置属性的属性值</p>
<p>   18 StringgetRealPath(String path) 返回一虚拟路径的真实路径</p>
<p>   19 String request.getContextPath() 返回上下文路径</p>
<p>2.response对象<br>   response对象包含了响应客户请求的有关信息，但在JSP中很少直接用到它。它是HttpServletResponse类的实例。<br>   response对象具有页面作用域，即访问一个页面时，该页面内的response对象只能对这次访问有效，其它页面的response对象对当前页面无效。</p>
<p>序号 方 法 说 明</p>
<p>   1 String getCharacterEncoding() 返回响应用的是何种字符编码</p>
<p>   2 ServletOutputStream getOutputStream() 返回响应的一个二进制输出流</p>
<p>   3 PrintWriter getWriter() 返回可以向客户端输出字符的一个对象</p>
<p>   4 void setContentLength(int len) 设置响应头长度</p>
<p>   5 void setContentType(String type) 设置响应的MIME类型</p>
<p>   6 sendRedirect(java.lang.String location) 重新定向客户端的请求</p>
<p>3.session对象</p>
<p>   session对象指的是客户端与服务器的一次会话，从客户端连到服务器的一个WebApplication开始，直到客户端与服务器断开连接为止。它是HttpSession类的实例。<br>   Session对象是一个JSP内置对象，它在第一个JSP页面被装载时自动创建，完成会话期管理。从一个客户打开浏览器并连接到服务器开始，到客户关闭浏览器离开这个服务器结束，被称为一个会话。当一个客户访问一个服务器时，可能会在这个服务器的几个页面之间切换，服务器应当通过某种办法知道这是一个客户，就需要Session对象。<br>   session对象具有会话作用域。</p>
<p>序号 方 法 说 明</p>
<p>   1 long getCreationTime() 返回SESSION创建时间</p>
<p>   2 public String getId() 返回SESSION创建时JSP引擎为它设的唯一ID号</p>
<p>   3 long getLastAccessedTime() 返回此SESSION里客户端最近一次请求时间</p>
<p>   4 int getMaxInactiveInterval() 返回两次请求间隔多长时间此SESSION被取消(ms)</p>
<p>   5 String[] getValueNames() 返回一个包含此SESSION中所有可用属性的数组</p>
<p>   6 void invalidate() 取消SESSION，使SESSION不可用</p>
<p>   7 boolean isNew() 返回服务器创建的一个SESSION,客户端是否已经加入</p>
<p>   8 void removeValue(String name) 删除SESSION中指定的属性</p>
<p>   9 void setMaxInactiveInterval() 设置两次请求间隔多长时间此SESSION被取消(ms)</p>
<p>4.out对象<br>   out对象是JspWriter类的实例,是向客户端输出内容常用的对象</p>
<p>序号 方 法 说 明</p>
<p>   1 void clear() 清除缓冲区的内容</p>
<p>   2 void clearBuffer() 清除缓冲区的当前内容</p>
<p>   3 void flush() 清空流</p>
<p>   4 int getBufferSize() 返回缓冲区以字节数的大小，如不设缓冲区则为0</p>
<p>   5 int getRemaining() 返回缓冲区还剩余多少可用</p>
<p>   6 boolean isAutoFlush() 返回缓冲区满时，是自动清空还是抛出异常</p>
<p>   7 void close() 关闭输出流</p>
<p>5.page对象<br>   page对象就是指向当前JSP页面本身，有点象类中的this指针，它是java.lang.Object类的实例</p>
<p>序号 方 法 说 明</p>
<p>   1 class getClass 返回此Object的类</p>
<p>   2 int hashCode() 返回此Object的hash码</p>
<p>   3 boolean equals(Object obj) 判断此Object是否与指定的Object对象相等</p>
<p>   4 void copy(Object obj) 把此Object拷贝到指定的Object对象中</p>
<p>   5 Object clone() 克隆此Object对象</p>
<p>   6 String toString() 把此Object对象转换成String类的对象</p>
<p>   7 void notify() 唤醒一个等待的线程</p>
<p>   8 void notifyAll() 唤醒所有等待的线程</p>
<p>   9 void wait(int timeout) 使一个线程处于等待直到timeout结束或被唤醒</p>
<p>   10 void wait() 使一个线程处于等待直到被唤醒</p>
<p>   11 void enterMonitor() 对Object加锁</p>
<p>   12 void exitMonitor() 对Object开锁</p>
<p>6.折叠application对象<br>   application对象实现了用户间数据的共享，可存放全局变量。它开始于服务器的启动，直到服务器的关闭，在此期间，此对象将一直存在;这样在用户的前后连接或不同用户之间的连接中，可以对此对象的同一属性进行操作;在任何地方对此对象属性的操作，都将影响到其他用户对此的访问。服务器的启动和关闭决定了application对象的生命。它是ServletContext类的实例。</p>
<p>序号 方 法 说 明</p>
<p>   1 Object getAttribute(String name) 返回给定名的属性值</p>
<p>   2 Enumeration getAttributeNames() 返回所有可用属性名的枚举</p>
<p>   3 void setAttribute(String name,Object obj) 设定属性的属性值</p>
<p>   4 void removeAttribute(String name) 删除一属性及其属性值</p>
<p>   5 String getServerInfo() 返回JSP(SERVLET)引擎名及版本号</p>
<p>   6 String getRealPath(String path) 返回一虚拟路径的真实路径</p>
<p>   7 ServletContext getContext(String uripath) 返回指定WebApplication的application对象</p>
<p>   8 int getMajorVersion() 返回服务器支持的Servlet API的最大版本号</p>
<p>   9 int getMinorVersion() 返回服务器支持的Servlet API的最小版本号</p>
<p>   10 String getMimeType(String file) 返回指定文件的MIME类型</p>
<p>   11 URL getResource(String path) 返回指定资源(文件及目录)的URL路径</p>
<p>   12 InputStream getResourceAsStream(String path) 返回指定资源的输入流</p>
<p>   13 RequestDispatcher getRequestDispatcher(String uripath) 返回指定资源的RequestDispatcher对象</p>
<p>   14 Servlet getServlet(String name) 返回指定名的Servlet</p>
<p>   15 Enumeration getServlets() 返回所有Servlet的枚举</p>
<p>   16 Enumeration getServletNames() 返回所有Servlet名的枚举</p>
<p>   17 void log(String msg) 把指定消息写入Servlet的日志文件</p>
<p>   18 void log(Exception exception,String msg) 把指定异常的栈轨迹及错误消息写入Servlet的日志文件</p>
<p>   19 void log(String msg,Throwable throwable) 把栈轨迹及给出的Throwable异常的说明信息 写入Servlet的日志文件</p>
<p>7.折叠exception对象<br>   exception对象是一个例外对象，当一个页面在运行过程中发生了例外，就产生这个对象。如果一个JSP页面要应用此对象，就必须把isErrorPage设为true，否则无法编译。他实际上是java.lang.Throwable的对象</p>
<p>序号 方 法 说 明</p>
<p>   1 String getMessage() 返回描述异常的消息</p>
<p>   2 String toString() 返回关于异常的简短描述消息</p>
<p>   3 void printStackTrace() 显示异常及其栈轨迹</p>
<p>   4 Throwable FillInStackTrace() 重写异常的执行栈轨迹</p>
<p>8.折叠pageContext对象<br>   pageContext对象提供了对JSP页面内所有的对象及名字空间的访问，也就是说他可以访问到本页所在的SESSION，也可以取本页面所在的application的某一属性值，他相当于页面中所有功能的集大成者，它的本类名也叫pageContext。</p>
<p>序号 方 法 说 明</p>
<p>   1 JspWriter getOut() 返回当前客户端响应被使用的JspWriter流(out)</p>
<p>   2 HttpSession getSession() 返回当前页中的HttpSession对象(session)</p>
<p>   3 Object getPage() 返回当前页的Object对象(page)</p>
<p>   4 ServletRequest getRequest() 返回当前页的ServletRequest对象(request)</p>
<p>   5 ServletResponse getResponse() 返回当前页的ServletResponse对象(response)</p>
<p>   6 Exception getException() 返回当前页的Exception对象(exception)</p>
<p>   7 ServletConfig getServletConfig() 返回当前页的ServletConfig对象(config)</p>
<p>   8 ServletContext getServletContext() 返回当前页的ServletContext对象(application)</p>
<p>   9 void setAttribute(String name,Object attribute) 设置属性及属性值</p>
<p>   10 void setAttribute(String name,Object obj,int scope) 在指定范围内设置属性及属性值</p>
<p>   11 public Object getAttribute(String name) 取属性的值</p>
<p>   12 Object getAttribute(String name,int scope) 在指定范围内取属性的值</p>
<p>   13 public Object findAttribute(String name) 寻找一属性,返回起属性值或NULL</p>
<p>   14 void removeAttribute(String name) 删除某属性</p>
<p>   15 void removeAttribute(String name,int scope) 在指定范围删除某属性</p>
<p>   16 int getAttributeScope(String name) 返回某属性的作用范围</p>
<p>   17 Enumeration getAttributeNamesInScope(int scope) 返回指定范围内可用的属性名枚举</p>
<p>   18 void release() 释放pageContext所占用的资源</p>
<p>   19 void forward(String relativeUrlPath) 使当前页面重导到另一页面</p>
<p>   20 void include(String relativeUrlPath) 在当前位置包含另一文件</p>
<p>9.折叠config对象<br>   config对象是在一个Servlet初始化时，JSP引擎向它传递信息用的，此信息包括Servlet初始化时所要用到的参数(通过属性名和属性值构成)以及服务器的有关信息(通过传递一个ServletContext对象)</p>
<p>序号 方 法 说 明</p>
<p>   1 ServletContext getServletContext() 返回含有服务器相关信息的ServletContext对象</p>
<p>   2 String getInitParameter(String name) 返回初始化参数的值</p>
<p>   3 Enumeration getInitParameterNames() 返回Servlet初始化所需所有参数的枚举</p>
<p>内置对象产生的时机<br>   一个JSP页面对应一个Servlet类，每个Servlet类有三个方法:</p>
<p>   init方法:初始化JSP/Servlet的方法。</p>
<p>   destory方法:销毁JSP/Servlet的方法。</p>
<p>   service方法:对用户请求产生响应的方法。</p>
<p>request对象和response对象是service方法的形参，application对象，page对象，out对象，pageContext对象，session对象都是service的方法中生成的实例。这些内容在struts自媒体网站上有详细的介绍。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/14/jsp%E4%B9%9D%E5%A4%A7%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/" data-id="ck3b80zem0007p0r9gzgj8vhd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-cookie有效期" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/14/cookie%E6%9C%89%E6%95%88%E6%9C%9F/" class="article-date">
  <time datetime="2019-11-14T10:35:35.000Z" itemprop="datePublished">2019-11-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/14/cookie%E6%9C%89%E6%95%88%E6%9C%9F/">cookie有效期</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Cookie的有效期<br>Cookie的maxAge决定着Cookie的有效期，单位为秒（Second）。Cookie中通过getMaxAge()方法与setMaxAge(int maxAge)方法来读写maxAge属性。 如果maxAge属性为正数，则表示该Cookie会在maxAge秒之后自动失效。浏览器会将maxAge为正数的Cookie持久化，即写到对应的Cookie文件中。无论客户关闭了浏览器还是电脑，只要还在maxAge秒之前，登录网站时该Cookie仍然有效。下面代码中的Cookie信息将永远有效。</p>
<p><span style="color:#333333"><code>Cookie cookie = <span style="color:#0000ff">new</span> Cookie(<span style="color:#a31515">"username"</span>,<span style="color:#a31515">"helloweenvsfei"</span>); <span style="color:green">// 新建Cookie</span><br>cookie.setMaxAge(Integer.MAX_VALUE); <span style="color:green">// 设置生命周期为MAX_VALUE</span><br>response.addCookie(cookie); <span style="color:green">// 输出到客户端</span></code></span><br>如果maxAge为负数，则表示该Cookie仅在本浏览器窗口以及本窗口打开的子窗口内有效，关闭窗口后该Cookie即失效。maxAge为负数的Cookie，为临时性Cookie，不会被持久化，不会被写到Cookie文件中。Cookie信息保存在浏览器内存中，因此关闭浏览器该Cookie就消失了。Cookie默认的maxAge值为–1。</p>
<p>如果maxAge为0，则表示删除该Cookie。Cookie机制没有提供删除Cookie的方法，因此通过设置该Cookie即时失效实现删除Cookie的效果。失效的Cookie会被浏览器从Cookie文件或者内存中删除：</p>
<p><span style="color:#333333"><code>Cookie cookie = <span style="color:#0000ff">new</span> Cookie(<span style="color:#a31515">"username"</span>,<span style="color:#a31515">"helloweenvsfei"</span>); <span style="color:green">// 新建Cookie</span><br>cookie.setMaxAge(0); <span style="color:green">// 设置生命周期为0，不能为负数</span><br>response.addCookie(cookie); <span style="color:green">// 必须执行这一句</span></code></span><br>response对象提供的Cookie操作方法只有一个添加操作add(Cookie cookie)。要想修改Cookie只能使用一个同名的Cookie来覆盖原来的Cookie，达到修改的目的。删除时只需要把maxAge修改为0即可。</p>
<p>注意：从客户端读取Cookie时，包括maxAge在内的其他属性都是不可读的，也不会被提交。浏览器提交Cookie时只会提交name与value属性。maxAge属性只被浏览器用来判断Cookie是否过期。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/14/cookie%E6%9C%89%E6%95%88%E6%9C%9F/" data-id="ck3b80zdn0003p0r906aw60z1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-cookie机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/14/cookie%E6%9C%BA%E5%88%B6/" class="article-date">
  <time datetime="2019-11-14T10:24:28.000Z" itemprop="datePublished">2019-11-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/14/cookie%E6%9C%BA%E5%88%B6/">cookie机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Cookie机制<br>Cookie技术是客户端的解决方案，Cookie就是由服务器发给客户端的特殊信息，而这些信息以文本文件的方式存放在客户端，然后客户端每次向服务器发送请求的时候都会带上这些特殊的信息。让我们说得更具体一些：当用户使用浏览器访问一个支持Cookie的网站的时候，用户会提供包括用户名在内的个人信息并且提交至服务器；接着，服务器在向客户端回传相应的超文本的同时也会发回这些个人信息，当然这些信息并不是存放在HTTP响应体（Response Body）中的，而是存放于HTTP响应头（Response Header）；当客户端浏览器接收到来自服务器的响应之后，浏览器会将这些信息存放在一个统一的位置，对于Windows操作系统而言，我们可以从： [系统盘]:\Documents and Settings[用户名]\Cookies目录中找到存储的Cookie；自此，客户端再向服务器发送请求的时候，都会把相应的Cookie再次发回至服务器。而这次，Cookie信息则存放在HTTP请求头（Request Header）了。有了Cookie这样的技术实现，服务器在接收到来自客户端浏览器的请求之后，就能够通过分析存放于请求头的Cookie得到客户端特有的信息，从而动态生成与该客户端相对应的内容。通常，我们可以从很多网站的登录界面中看到“请记住我”这样的选项，如果你勾选了它之后再登录，那么在下一次访问该网站的时候就不需要进行重复而繁琐的登录动作了，而这个功能就是通过Cookie实现的。</p>
<p>在程序中，会话跟踪是很重要的事情。理论上，一个用户的所有请求操作都应该属于同一个会话，而另一个用户的所有请求操作则应该属于另一个会话，二者不能混淆。例如，用户A在超市购买的任何商品都应该放在A的购物车内，不论是用户A什么时间购买的，这都是属于同一个会话的，不能放入用户B或用户C的购物车内，这不属于同一个会话。</p>
<p>而Web应用程序是使用HTTP协议传输数据的。HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。即用户A购买了一件商品放入购物车内，当再次购买商品时服务器已经无法判断该购买行为是属于用户A的会话还是用户B的会话了。要跟踪该会话，必须引入一种机制。</p>
<p>Cookie就是这样的一种机制。它可以弥补HTTP协议无状态的不足。在Session出现之前，基本上所有的网站都采用Cookie来跟踪会话。</p>
<p>如果你把Cookies看成为http协议的一个扩展的话，理解起来就容易的多了，其实本质上cookies就是http的一个扩展。有两个http头部是专门负责设置以及发送cookie的,它们分别是Set-Cookie以及Cookie。当服务器返回给客户端一个http响应信息时，其中如果包含Set-Cookie这个头部时，意思就是指示客户端建立一个cookie，并且在后续的http请求中自动发送这个cookie到服务器端，直到这个cookie过期。如果cookie的生存时间是整个会话期间的话，那么浏览器会将cookie保存在内存中，浏览器关闭时就会自动清除这个cookie。另外一种情况就是保存在客户端的硬盘中，浏览器关闭的话，该cookie也不会被清除，下次打开浏览器访问对应网站时，这个cookie就会自动再次发送到服务器端。一个cookie的设置以及发送过程分为以下四步：</p>
<p>客户端发送一个http请求到服务器端 服务器端发送一个http响应到客户端，其中包含Set-Cookie头部 客户端发送一个http请求到服务器端，其中包含Cookie头部 服务器端发送一个http响应到客户端</p>
<p>这个通讯过程也可以用以下下示意图来描述：</p>
<p>在客户端的第二次请求中包含的Cookie头部中，提供给了服务器端可以用来唯一标识客户端身份的信息。这时，服务器端也就可以判断客户端是否启用了cookies。尽管，用户可能在和应用程序交互的过程中突然禁用cookies的使用，但是，这个情况基本是不太可能发生的，所以可以不加以考虑，这在实践中也被证明是对的。</p>
<p>除了cookies,客户端还可以将发送给服务器的数据包含在请求的url中，比如请求的参数或者请求的路径中。 我们来看一个常规的http get 请求例子：</p>
<p>GET /index.php?foo=bar HTTP/1.1 Host: example.org</p>
<p>另外一种客户端传递数据到服务器端的方式是将数据包含在http请求的内容区域内。 这种方式需要请求的类型是POST的，看下面一个例子：</p>
<p>POST /index.php HTTP/1.1 Host: example.org Content-Type: application/x-www-form-urlencoded Content-Length: 7</p>
<p>foo=bar</p>
<p>在一个请求中，可以同时包含这两种形式的数据：</p>
<p>POST /index.php?myget=foo HTTP/1.1 Host: example.orgContent-Type: application/x-www-form-urlencoded Content-Length: 11</p>
<p>mypost=bar</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/14/cookie%E6%9C%BA%E5%88%B6/" data-id="ck3b80zdp0004p0r99tzadltw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/14/hello-world/" class="article-date">
  <time datetime="2019-11-14T09:54:15.664Z" itemprop="datePublished">2019-11-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/14/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/14/hello-world/" data-id="ck3b80zdr0005p0r9g4dqfrbp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/11/23/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">Java集合框架</a>
          </li>
        
          <li>
            <a href="/2019/11/20/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/">EL表达式</a>
          </li>
        
          <li>
            <a href="/2019/11/15/Java%E7%9F%A5%E8%AF%86%E7%82%B9/">Java知识点</a>
          </li>
        
          <li>
            <a href="/2019/11/14/Java%E6%8E%A5%E5%8F%A3%E6%80%BB%E7%BB%93/">Java接口总结</a>
          </li>
        
          <li>
            <a href="/2019/11/14/jsp%E4%B9%9D%E5%A4%A7%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/">jsp九大内置对象</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>