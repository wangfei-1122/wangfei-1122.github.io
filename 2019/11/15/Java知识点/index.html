<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Java知识点 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="javaSE（标准版） javaEE（企业版） javaME（微型版）JDK（java开发工具包）JRE（java运行环境）IDE（集成开发环境）Java SE（Java Platform，Standard Edition）。Java SE 以前称为 J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程序。Java SE 包含了支持 Java Web 服务开发的">
<meta property="og:type" content="article">
<meta property="og:title" content="Java知识点">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;11&#x2F;15&#x2F;Java%E7%9F%A5%E8%AF%86%E7%82%B9&#x2F;index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="javaSE（标准版） javaEE（企业版） javaME（微型版）JDK（java开发工具包）JRE（java运行环境）IDE（集成开发环境）Java SE（Java Platform，Standard Edition）。Java SE 以前称为 J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程序。Java SE 包含了支持 Java Web 服务开发的">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-11-15T01:21:16.580Z">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Java知识点" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/15/Java%E7%9F%A5%E8%AF%86%E7%82%B9/" class="article-date">
  <time datetime="2019-11-15T01:20:41.000Z" itemprop="datePublished">2019-11-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java知识点
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>javaSE（标准版） javaEE（企业版） javaME（微型版）<br>JDK（java开发工具包）JRE（java运行环境）IDE（集成开发环境）<br>Java SE（Java Platform，Standard Edition）。Java SE 以前称为 J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程序。Java SE 包含了支持 Java Web 服务开发的类，并为 Java Platform，Enterprise Edition（Java EE）提供基础。 J2SE就是做那种桌面安装程序样的，像QQ，WORD那种应用程序。<br>Java EE（Java Platform，Enterprise Edition）。这个版本以前称为 J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端 Java 应用程序。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web 2.0 应用程序。 J2EE 就是做基于Internet的应用程序，像选课系统，企业网站，银行系统之类的。<br>Java ME（Java Platform，Micro Edition）。这个版本以前称为 J2ME。Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME 包括灵活的用户界面、健壮的安全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序的丰富支持。基于 Java ME 规范的应用程序只需编写一次，就可以用于许多设备，而且可以利用每个设备的本机功能。 J2ME就是做嵌入式系统开发的，像手机游戏之类的，像现在流行的Android操作系统。<br>JDK（Java Development Kit）。<br>JRE（Java Runtime Environment）<br>IDE（Ind Depvelopment Environment）<br>一、面向对象<br>类、对象、变量<br>（1）所有的Java程序都已类class为组织单元；类由属性和方法两部分组成<br>（2）先创建对象，再使用对象<br>（3）成员变量：类中定义，自动定义初始值<br>局部变量：类方法中定义（两变量同名，局部变量有更高的优先级）<br>构造方法<br>构造方法是定义在java类中的一个用来初始化对象的方法，与类同名且没有返回值。<br>public 构造方法名（）{<br>}<br>其中构造方法名与类同名；当没有指定的构造方法时，系统会自动添加无参构造方法<br>Static使用<br>Static修饰的成员属于整个类，被类的所有对象共享。可通过使用类名直接访问静态成员，也可通过对象名<br>Static可以修饰变量、方法和代码块<br>（1）Static使用之静态方法<br>public class Helloworld {<br>public static void print() {<br>System.out.println(“***”);<br>}<br>public static void main(String[] args) {<br>    Helloworld.print();<br>    Helloworld demo = new Helloworld;<br>    demo.print();<br>}<br>}<br>注意：静态方法中可以直接调用同类的静态成员，但不可以直接调用非静态成员；普通成员方法中可以直接访问同类的非静态变量和静态变量；静态方法中不能直接调用非静态成员方法<br>（2）Static使用之静态初始化块<br>静态初始化块在类加载时执行，且只会执行一次，同时静态初始化块只能给静态变量赋值，不能初始化普通成员<br>public class Helloworld {<br>int num1;<br>int num2;<br>static int num3;<br>public Helloworld() {<br>    num1 = 91;<br>    System.out.println(“构造方法为num1赋值”);<br>    num2 = 74;<br>    System.out.println(“初始化块为num2赋值”);<br>    num3 = 83;<br>    System.out.println(“静态初始化块为num3赋值”);<br>}</p>
<p>public static void main(String[] args) {<br>    Helloworld hello = new Helloworld();<br>    System.out.println(hello.num1);<br>    System.out.println(hello.num2);<br>    System.out.println(num3);<br>    Helloworld hello2 = new Helloworld();<br>}<br>}<br>运行结果：静态初始化块为num3赋值<br>初始化块为num2赋值<br>构造方法为num1赋值<br>91<br>74<br>83<br>初始化块为num2赋值<br>构造方法为num1赋值<br>二、java面向对象的特性<br>封装性：将类的某些信息隐藏在内部，通过类的方法来实现操作访问<br>步骤：<br>1 修改属性可见性；<br>2 创建getter\setter方法；<br>3在方法中加入属性控制语句<br>(1)静态内部类:<br>public class SOuter {<br>private int a = 99;<br>static int b = 1;<br>public static class SInner {<br>    int b = 2;</p>
<pre><code>public void test() {
    System.out.println(&quot;访问外部类b&quot; + SOuter.b);
    System.out.println(&quot;访问内部类b&quot; + b);
}</code></pre><p>}</p>
<p>public static void main(String[] args) {</p>
<pre><code>//三行表示
SInner sInner;
sInner = new SInner();
sInner.test();

//两行表示
SInner si = new SInner();
si.test();

//一行表示
new SInner().test();</code></pre><p>}<br>}<br>(2)成员内部类：访问外部类时使用this指针<br>（3）方法内部类：只能在该方法中使用，且不能使用访问控制符和Static修饰符<br>2. 继承性<br>（1）一般形式：class 子类 extends 父类<br>（2）方法重写：子类对继承的父类方法不满意可以重写，调用时优先调用子类方法<br>（3）继承的初始化顺序：先初始化父类，再到子类；先执行初始化对象中属性，再执行狗在方法中的初始化<br>（4）父类对象–属性初始化–构造方法–子类对象–属性初始化–构造方法<br>（5）注意：如果子类构造方法中没有显示调用父类的构造方法，默认调用父类无参构造方法，若此父类没用无参的构造方法，则编译出错<br>多态性<br>引用多态：父类的引用可以指向本类的对象，也可指向子类的对象<br>方法多态：创建本类对象时，调用的方法为本类方法；创建子类对象时，调用的方法为子类的重写的方法或者继承的方法<br>（1）抽象类<br>用关键字abstract修饰：抽象类只用声明不需要实现；包含抽象方法的类为抽象类；抽象类不能直接创建，可以定义引用变量。<br>public abstract class Telphone{<br>public abstract void call(); //抽象方法没有方法体，以分号结束<br>}<br>（2）接口（一种特殊的类，有全局变量和公共抽象方法组成）<br>[修饰符] class 类名 extends 父类implemrnts 接口1,2……<br>{类体部分<br>}<br>注：接口经常与匿名内部类配合使用<br>public interface Iplay{<br>public void phone();<br>}<br>public class People implements Iplay{<br>public static void main(String[] args){<br>People test=new People();<br>test.phone();<br>}<br>public void phone(){<br>System.out.println(“手机可以玩游戏”);<br>}<br>}<br>1.String、StringBuilder、StringBuffer的区别是什么，String为什么是不可变的？<br>不可变性<br>String类的底层源码中，通过final关键字修饰字符串数组，private final char value[]，所以是不可变的。StringBuffer和StringBuilder类是集成自 AbstractStringBuilder 类， AbstractStringBuilder 类中的变量没有用final关键字修饰，所以是可变的。<br>线程安全性<br>String是不可变的，是常量，所以是线程安全的。StringBuilder和StringBuffer都继承自AbstractStringBuilder 类，StringBuffer对方法加了同步锁，所以是线程安全的，而StringBuilder没有加同步锁，所以是线程不安全的。<br>性能<br>对String类型进行改变是都会new一个新的string对象，并指向新的对象；<br>StringBuffer直接通过改变自身变量的值，StringBuilder相对能提升性能，但有线程不安全的情况。<br>2.== 与 equals<br>==用来判断两个对象是否相等，基础数据类型比较的是值是否相等。<br>没有重写对象的equals方法时，也是用来比较两个对象是否相等，重写equals方法可以比较内容相等，返回true<br>3.try/catch/finally中finally是否一定执行<br>在以下4种特殊情况下，finally块不会被执行:<br>在finally语句块中发生了异常。<br>在前面的代码中用了System.exit()退出程序。<br>程序所在的线程死亡。<br>关闭CPU。<br>4.接口和抽象类的区别？<br>1.抽象类中可以实现方法，抽象接口不能实现方法（jdk1.8以后可以实现方法）；<br>2.接口中的变量默认是final类型，而抽象类不是；<br>3.类只能继承一个抽象类，而接口可以实现多个；<br>4.类继承接口需要实现所有方法，抽象类不需要；<br>5.接口不能用new实例化，可以声明。必须引用一个实现该接口的对象抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。<br>5.Arraylist 与 LinkedList 异同<br>安全性<br>ArrayList与LinkedList都是线程不安全的。<br>数据结构实现<br>ArryayList是基于Object数组，而LinkedList是基于双向循环链表（JDK1.6之前为循环链表，之后取消了循环）<br>插入删除的影响<br>ArrayList采用数组存储，插入删除受元素位置的影响；<br>LinkedList采用链表存储，插入删除不收元素位置影响；<br>访问元素<br>LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。<br>实现了RandomAccess接口的list，优先选择普通for循环 ，其次foreach,未实现RandomAccess接口的list， 优先选择iterator遍历(foreach遍历底层也是通过iterator实现的)，大size的数据，千万不要使用普通for循环<br>6.ArrayList 与 Vector 区别<br>Vector中所有方法都是同步的，在多线程操作中，同步操作会耗费时间，而ArrayList是不需要同步的，在不需要考虑线程安全时可以使用。<br>7.HashMap的底层实现<br>待补充完善<br>8.HashSet 和 HashMap 区别<br>HashMap实现Map接口，用来存储键值对，调用put方法添加元素，使用Key计算Hashcode，而HashSet实现Set接口，用来存储对象，调用add方法添加对象，使用对象计算hashcode，根据equals方法判断对象相等，执行效率的话，HashMap优与HashSet。<br>9.ConcurrentHashMap 和 Hashtable 的区别<br>ConcurrentHashMap 和 HashTable 的区别主要体现在实现线程安全的方式上不同。ConcurrentHashMap使用的是分段锁，HashTable使用的是同一把锁，因而在多线程并发中效率很低。<br>10.多线程实现方式<br>1.继承Thread类，2.实现Runnable接口，3.基于线程池实现</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/11/15/Java%E7%9F%A5%E8%AF%86%E7%82%B9/" data-id="ck3b8w0vr0007pgr946yx41ua" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/11/20/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          EL表达式
        
      </div>
    </a>
  
  
    <a href="/2019/11/14/Java%E6%8E%A5%E5%8F%A3%E6%80%BB%E7%BB%93/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Java接口总结</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/11/23/jQuery%E6%9C%89%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/">jQuery有关知识点</a>
          </li>
        
          <li>
            <a href="/2019/11/23/ajax%E8%AF%B7%E6%B1%82%E7%9A%84%E4%BA%94%E4%B8%AA%E6%AD%A5%E9%AA%A4/">ajax请求的五个步骤</a>
          </li>
        
          <li>
            <a href="/2019/11/23/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/">Java集合框架</a>
          </li>
        
          <li>
            <a href="/2019/11/20/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/">EL表达式</a>
          </li>
        
          <li>
            <a href="/2019/11/15/Java%E7%9F%A5%E8%AF%86%E7%82%B9/">Java知识点</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>